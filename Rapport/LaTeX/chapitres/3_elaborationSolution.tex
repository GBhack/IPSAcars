\subsection{Circuit}


\subsection{Robot}

	\subsubsection{Suivi de trajectoire}

		Afin d’offrir une capacité de suivi de trajectoire simple et robuste, il a été décidé d’intégrer au robot la fonctionnalité "suivi de ligne". Il s’agit de l’une des méthodes les plus répandues\cite{bib3} \cite{bib4}, relativement simple à implémenter et économe aussi bien en composants qu’en puissance de calcul nécessaire.\\

		L’idée est d’offrir une base fiable et simple pour que le suivi de trajectoire ne soit pas une source de préoccupation ou d’erreur dans le cas d'utilisations centrées sur d’autres problématiques (dans le cadre d'un TP sur la reconnaissance d'image, par exemple). Cela n’exclut cependant pas qu’un étudiant ou chercheur désireux d’explorer d’autres possibilités de suivi de trajectoire (via la caméra, un dispositif de triangulation ou autre) puisse se passer de ce module et exploiter une autre solution.\\

		Le principe de suivi de ligne est relativement simple : on place sur l’axe du robot, quelques millimètres au-dessus du sol, un capteur appelé « réflecteur optique ». Ce capteur émet une onde lumineuse (souvent infrarouge) et une cellule mesure l’intensité reçue sur la longueur d’onde émise. Une forte intensité reçue indiquera la présence d’une surface réfléchissante, tandis qu’une faible intensité indiquera la présence d’une surface absorbante. Il est ainsi aisé de différencier un fond sombre (la « route ») d’une ligne blanche.\\

		Une loi linéaire lie la tension lue en sortie de capteur à l'intensité reçue.\\
		Une simple lecture de cette tension permet, après comparaison avec des valeurs "seuil" définies expérimentalement, de savoir si le capteur se trouve au dessus d'une ligne blanche ou non.\\

		\begin{figure}[ht!]
			\centering
			\begin{minipage}{0.48\textwidth}
				\centering
				\includegraphics[scale=0.45]{Graphics/capteurOptiqueFondNoir.pdf}
				\caption{Capteur au dessus d'un support sombre}
			\end{minipage}\hfill
			\begin{minipage}{0.48\textwidth}
				\centering
				\includegraphics[scale=0.45]{Graphics/capteurOptiqueFondBlanc.pdf}
				\caption{Capteur au dessus d'un support clair}
			\end{minipage}
		\end{figure}

		La question qui se pose est celle du nombre de capteurs, et de leur disposition.\\

		Il est tout à fait possible de n'utiliser qu'un capteur : chaque fois qu'il quitte la ligne blanche, on entammera un virage à droite (puis à gauche si on ne retrouve pas la ligne blanche dans les quelques millisecondes suivantes) jusqu'à retrouver la ligne. Il est évident que cette méthode ne permettra pas une très grande fluidité de déplacement pour notre robot.

		\illu{capteurSimpleGauche.pdf}{Dépassement de la ligne sur la gauche}{1}
		\illu{capteurSimpleDroite.pdf}{Dépassement de la ligne sur la droite}{1}

		L'utilisation de deux capteurs permet une meilleure fluidité. On placera cette fois un capteur de chaque côté de la ligne.

		\illu{capteurDoubleGauche.pdf}{Dépassement de la ligne sur la gauche}{1.4}
		\illu{capteurDoubleDroit.pdf}{Dépassement de la ligne sur la droite}{1.4}

		Notons que, quelque soit la méthode employée, le suivi de ligne se résume toujours à un "rebondissement" des capteurs sur la ligne. Aussi, pour obtenir une trajectoire aussi rectiligne que possible, il faudra "resserer" les capteurs au maximum autour de la ligne, et appliquer des corrections de faible amplitude.

		\illu{capteurDoubleEcartFort.pdf}{Ecart important entre les capteurs}{1}
		\illu{capteurDoubleEcartFaible.pdf}{Ecart réduit entre les capteurs}{1}

		Nous pourrons éventuellement introduire un amortissement progressif de la correction via un régulateur PID\nomenclature{PID}{Proportionnel, Intégrateur, Dérivateur}, mais cela peut introduire de nombreuses problématiques dans des cas d'utilisation plus complexes.\\

		Nous retiendrons donc à ce stade la solution consistant en deux capteurs placés de part et d'autre de la ligne. Nous veillerons à ce que le placement des capteurs permette une détection de très faibles écarts de trajectoire, sans pour autant induire des ambiguités de mesure.\\

		Intéressons nous maintenant au cas d'une trajectoire courbe. Le fait d'avoir privilégié l'application de faibles corrections peut alors s'avérer problématique si ces dernières ne sont pas suffisantes pour adapter la trajectoire.

		\illu{perteTrajectoireVirage.pdf}{Perte de trajectoire en virage dû à de trop faibles corrections}{1.5}

		Pour obtenir un fluidité de déplacement raisonnable tout en assurant la possibilité de suivre des trajectoires courbes à rayon de virage réaliste, nous placerons une deuxième série de capteurs "encadrant" les capteurs principaux. Une détection de ligne par ces capteurs déclanchera une correction plus importante.

		\illu{trajectoireVirage.pdf}{Maîtrise de la trajectoire en virage grâce à l'utilisation de 4 capteurs}{1.5}

		Cette solution consistant en l'utilisation de quatres reflecteurs optiques alignés de manière à encadre de près la ligne à suivre est sans doute l'une des plus simples imaginables en terme de réalisation mais également d'utilisation et de maintenance.
		Elle n'est malheureusement pas suffisante pour répondre à notre besoin. En effet, cette solution trouvera ses limites dès lors que notre Robot rencontrera sa première intersection, élément capital de ce projet.\\

		\illu{intersection4Capteurs.pdf}{Robot incapable de répondre à la présence d'une intersection}{1.5}

		Si on trouve dans la littérature de très nombreux exemples de réalisations de robots suiveurs de lignes, ces dernières se limitent toujours à des circuits sous forme de boucle. Notre défi est donc de mettre au point une solution permettant l'évolution du robot sur un circuit comprenant des intersections. Notre robot devra ne pas être "perturbé" au passage d'une intersection, mais surtout être capable d'emprunter toutes les directions qui lui sont offertes.\\

		La solution que nous avons mis au point consiste en l'introduction d'un capteur central et l'adoption d'un comportement "monolatéralement centré" du robot lors de la traversée d'intersections : lorsqu'il arrivera sur une intersection, le robot ne se souciera plus que de garder son capteur central sur la ligne, et ses capteurs latéraux \textbf{du côté de la direction choisie} à l'écart de cette dernière.

		\illu{intersection5CapteursTD.pdf}{Suivi de trajectoire sur une intersection (en choisissant d'aller tout droit)}{1.5}
		\illu{intersection5CapteursDroite.pdf}{Suivi de trajectoire sur une intersection (en choisissant d'aller à droite)}{1.5}

		Notons que la forme de la ligne devra être intélligemment faite, en présentant des rayons de courbures réalistes (un véhicule ne peut pas tourner à angle droit) et des intersections réalisables (notemment via l'utilisation de deux lignes séparées pour la circulation en sens contraires).\\

		Voici donc à quoi ressemblerait un carrefour:
		\illu{carrefour.pdf}{Carrefour en représentation "lignes"}{1.4}

		Pour pleinement définir la logique mise au point, illustrons la au travers de la situation la plus complexe que pourra rencontrer notre robot, qui est celle de la bifurcation à gauche.

		\illu{carrefour5capteursGauche.pdf}{Cas du virage à gauche sur un carrefour avec cinq capteurs}{1.5}

		\begin{enumerate}
			\item Le premier croisement ne nous intéresse pas. Nous allons continuer tout droit et éteignons donc la moitié droite de nos capteurs.
			\item Au passage du croisement, nous éteignons temporairement l'ensemble de nos capteurs.
			\item Le croisement passé, nous éteignons cette fois la moitié gauche de nos capteurs pour ne pas être perturbés par "la voie d'insertion".
			\item Peu de temps après, nous rallumons la moitié gauche et éteignons la moitié droite des capteurs pour suivre la voie bifurcant à gauche.
		\end{enumerate}

		Cette solution semble robuste tout en conservant une certaine simplicité d'implémantation. Elle sous-entend en revanche que le robot "sache" quand il arrive sur une intersection, mais également qu'il puisse évaluer à quelques millimètres près la distance qui le sépare des différentes "parties" de cette intersection (pour activer et désactiver ses capteurs en conséquence).\\

		La solution à cette problematique nous a été inspirée par le souvenir d'un brevet déposé en 2003 par le groupe PSA \cite{bib5}, qui proposait l'utilisation de code-barres tracés sur la route et que des capteurs placés sous le pare-choc des voiures pourraient "lire" pour prévenir le conducteur des sources de danger à venir (intersections, feux...).
		Il fut donc décidé que deux capteurs supplémentaires seraient ajoutés sur les extérieurs. Il augmenteraient ainsi la précision de placement sur la ligne, mais permettraient surtout de lire des "codes-barres" placés sur la piste. Ces code-barres devraient permettre au robot d'être averti de l'approche d'un carrefour (trois choix de direction possibles) ou d'une simple intersection (deux choix possibles). Nous avons simplement basé notre code sur une ligne simple ou doublée :\\
		\begin{figure}[H]
			\begin{tabu}to \textwidth {@{} | l | *3{X[c]|}@{}}
			  \hline
			   & \textbf{Gauche} & \textbf{Droite} & \textbf{Gauche ET Droite} \\
			  \hline
			  \textbf{Simple} & Impossible de tourner à droite & Impossible de tourner à gauche & Toutes possibilités offertes\\
			  \hline
			  \textbf{Double} & Obligation de tourner à gauche & Obligation de tourner à droite & Impossible d'aller tout droit \\
			  \hline
			\end{tabu}
			\caption{Formalisme employé pour les code-barres}
		\end{figure}

		Une code "doublé" serait composé de deux lignes elles mêmes séparées d'une épaisseur de ligne.
		Les codes seraient placés à 30cm du premier croisement.\\

		Dès la lecture d'un code au sol, le robot sera donc "attentif" à l'éventuelle apparition d'un doublon pendant environ deux centimètres. Si rien n'est lu passé cette distance, il en déduira qu'il s'agit d'un code simple. Il prendra alors une décision de direction (et pourra au passage en avertir les autres robots) et commencera un décompte de distance afin de gérer les activations et désactivations de ses capteurs jusqu'au franchissement de l'intersection.\\


		Illustrons ce système avec le cas de la bifurcation à gauche :

		\illu{carrefour7capteursGauche.pdf}{Cas du virage à gauche sur un carrefour avec sept capteurs}{1.5}

		\begin{enumerate}
			\item Lecture d'un code-barre : dans 30cm le robot aura la possibilité de tourner à droite et à gauche.
			\item Aucun doublon détecté dans les quelques centimètres suivants. La possibilité d'aller tout droit nous est donc offerte. Prise de décision quant à la direction (nous choisissons d'aller à gauche) et avertissement des autres robots en conséquence.
			\item Le premier croisement ne nous intéresse pas. Nous allons continuer tout droit et éteignons donc la moitié droite de nos capteurs.
			\item Au passage du croisement, nous éteignons temporairement l'ensemble de nos capteurs.
			\item Le croisement passé, nous éteignons cette fois la moitié gauche de nos capteurs pour ne pas être perturbés par "la voie d'insertion".
			\item Peu de temps après, nous rallumons la moitié gauche et éteignons la moitié droite des capteurs pour suivre la voie bifurcant à gauche.
		\end{enumerate}

		Le robot doit donc être conscient des distances parcourues avec une précision supérieure à deux centimètres. Le moyen le plus simple d'implémenter cette fonctionnalité est sans aucun doute au travers d'un encodeur incrémental placé sur l'axe de propulsion du robot.\\

		Nous pouvons donc considérer qu'à ce stade, nous disposons d'un solution satisfaisante répondant à la problématique du suivi de trajectoire.
		Cette solution répond précisément aux contraintes du projet, tout en conservant un certain niveau de simplicité. Elle est, pour rappel, constituée des éléments suivants :\\

		\begin{itemize}
			\item \textbf{Sur le circuit :} Un réseau de lignes blanches sur fond noir représentant les trajectoires empruntables par le robot.
			\item \textbf{Sur le robot :} Un ensemble de 7 réflecteurs optiques.
		\end{itemize}

	\subsubsection{Détection d'obstacles et de de signalisation}


	\subsubsection{Implémentation matérielle}

		\paragraph{Propulsion et direction}

			La solution la plus répendue en "petite robotique" consiste en l'utilisation de deux moteurs à courant continu pilotés indépendemment assurants à la fois la propulsion et la direction : on réduira les gaz à droite pour tourner de ce côté et réciproquement. Ces moteurs sont généralement pilotés en "PWM" \nomenclature{PWM}{Pulse-Width Modulation, ou Modulation de Largeur d'Impulsions}, mais d'autres solutions sont possibles et dépenderont de notre controleur. Beaucoup d'applications utilisent des chenilles ou des couroies en caoutchouc pour assurer la propulsion, mais nous privilégierons l'utilisations de roues à pneus, par soucis de simplification de la conception (l'emploi de chenilles ou de couroies induit  une grande précision d'usinage et de montage pour assurer le parallélisme des poulies et la tension de la courroie) et de réduction des coûts.\\

			L'utilisation d'un seul moteur de propulsion et d'une roue directionnelle pilotée par un servomoteur a longtemps été considérée, mais cette solution s'est révélée bien plus complexe à mettre en place et sans réel intéret particulier.\\

			\illu{virageDeuxMoteurs.pdf}{Virage à l'aide de deux moteurs indépendants}{1.5}

			L'espacement entre les deux roues $E$ est constant et connu.
			On fixera la vitesse appliquée à la roue à l'extérieur du virage $\omega_{ext}$ comme référence.
			On adaptera donc la vitesse de la roue à l'intérieur du virage $\omega_{int}$ en fonction du rayon de virage $R$ désiré.
			Il s'agit là d'une simple relation de Thales et on définit ainsi :
			\[\omega_{int} = \omega_{ext}\frac{R-E}{R}\]

			On peut donc obtenir n'importe quel rayon de virage en diminant simplement la vitesse de la roue à l'intérieur du virage.
			L'approximation selon laquelle la tension appliquée à un moteur et sa vitesse de rotation sont linéairement liés sera amplement suffisante dans le cadre de ce projet.\\

		\paragraph{Controleur}\label{Solution-controleur}

			Nous cherchons un controleur capable d'embarquer des applications en C (ou ses dérivés) et si possible en Python et/ou Matlab.
			Ce controleur devra être capable d'acquérir les données de différents capteurs et de commander deux moteurs au minimum (sans compter d'éventuelles sorties type LEDs).
			Le controleur devra également bénéficier d'une puissance de calcul suffisante les opérations de reconnaissance d'image.\\

			Ce dernier critère élimine d'office les microcontrolleurs 8 et 16 bits et donc les cartes de type "Arduino" dont la puissance de calcul et la capacité de traitement de flux est bien trop faible pour permettre une reconnaissance d'image supérieure à quelques pixels carrés.\\

			Nous nous sommes naturellement tournés vers la famille des micro-ordinateurs monocartes. Cette récente catégorie d'ordinateurs propose sur une carte de quelques centimètres de côté et pour moins d'une centaine d'euros un véritable ordinateur avec une connectivité réseau et USB, bien souvent vidéo, une puissance de calcul extremement confortable et la capacité de faire tourner des systèmes Linux et dérivés. Démocratisés en 2011 avec le Raspberry-Pi, ces ordinateurs se sont multipliés et l'offre est aujourd'hui très large. Nous avons ciblé notre selection sur les plus répendus (qui sont, de par leur succès, bien plus abordables et faciles à se procurer, et bénéficient d'une plus large et solide base documentaire) : les Raspberry-Pis, Beaglebones et UDOOs (pour ne citer qu'eux).\\

			Les UDOOs furent vite écartés en raison de leur prix.
			Le Raspberry-Pi 2 et BeagleBone Green se situent dans la même gamme de prix (autour de 40\$). Nous avons arrêté notre choix sur le BeagleBone Green (BBG\nomenclature{BBG}{BeagleBone Green}): ce dernier, contrairement au Raspberry-Pi 2, ne dispose pas de sortie vidéo (dont nous n'avons pas utilité au sein de ce projet) et possède une puissance de calcul légèrement inférieur à ce dernier (tout en restant extremement respectable) mais possède une mémoire intégrée (ce qui dispense de l'achat d'une carte séparée) et surtout de capacités d'entrées/sorties numériques et analogiques bien supérieures. Ce point nous est extremement important: en effet, le Raspberry-Pi n'est capable de générer qu'un signal PWM et ne possède aucune entrée analogique ce qui aurait nécéssité l'utilisation de "périphériques" supplémentaires pour la gestion des moteurs et des capteur et donc alourdi les coûts et la complexité de conception, augmenté le nombre de sources potentielles de pannes...\\

			Nous utiliserons donc un BeagleBone-Green Wireless :
			\illu{BBG.jpg}{Le BeagleBone Green \textit{\textbf{(source : seeedstudio.com)}}}{0.45}

			Ce dernier est équipé d'un processeur ARM 32bits à 1Ghz, de 512Mo de RAM de 4Go de mémoire embarquée et d'un impressionante capacité de communication : 7 entrées analogiques (la carte comprend un convertisseur analogique-numérique 12bits), 65 entrees/sorties numériques (0 ou 3.3V) et bénéficie même de fonctionnalités telles qu'un compteur d'impulsion intégré au processeur (particulièrement utile pour l'interfaçage de notre encodeur). La carte consomme moins de 1,5W et coûte 45\$ \cite{bib6}.
			Nous la "chapeauterons" d'une carte d'extension que nous réaliserons nous même pour faire l'interface entre les ports d'extension et nos différents capteurs et actionneurs (voir \ref{carteMere}, page \pageref{carteMere}).\\

			Notons que le BBG doit être alimenté en 5V, et travaille avec un niveau logic "CMOS" de 3.3V. Les entrées et sorties numériques devront donc être compatibles (niveau haut supérieur à 2.5V et inférieur ou égal à 3.3V et niveau bas inférieur à 1.3V).

		\paragraph{Suivi de ligne}

			Comme dit précédemment, nous utiliserons sept réflecteurs optiques infrarouges pour effectuer le suivi de ligne.
			Un réflecteur optique est composé d'une LED \nomenclature{LED}{Light-Emitting Diode, ou Diode Electro-Luminescente} (ici infrarouge) et d'un phototransistor. Le phototransistor est comparable à un transistor classique, dont le courant de base serait remplacé par une intensité lumineuse, ou plus simplement encore comme une résistance variable en fonction de l'intensité lumineuse reçue.\\

			Nous utiliserons des TCRT5000, très répendus.\\

			Les capteurs nous fournissent donc une tension variable qu'il faudra pouvoir exploiter : au dessus d'une certaine valeur de cette tension, nous pourrons conclure en la présence d'une ligne blanche (forte réflectivité).\\

			Deux solution s'offrent à nous : ou bien concevoir un montage basé sur un comparateur et une résistance variable (pour régler la valeur seuil) afin d'obtenir une sortie booléenne (par exemple : 5V en présence d'une ligne blanche et 0V sinon) qui pourra très simplement être lue sur n'importe quelle entrée numérique du controleur, ou bien tirer partie de l'encodeur analogique-numérique intégré au controleur pour lire la valeur directement. Nous privilégierons cette méthode qui permet de limiter le nombre de composants, et donc le coût et les sources de pannes.\\

			Le BeagleBone Green possède sept entrées analogiques (nous avons justement sept capteurs) capables de discerner $2^{12} = 4096$ niveaux différents linéairement répartis entre 0 et 1,8V\cite{bib6}.
			Ainsi, l'application d'une tension de 0V à l'une de ce entrées nous permettra de lire la valeur "0" logiciellement, 2048 pour 0,9V, 4096 pour 1,8V etc... Nous prendrons garde à ne jamais dépasser cette valeur sous peine d'endomager le controleur. Le BBG fournit une tension de 1.8 spécifiquement pour cette application\cite{bib6}.\\

			La datasheet du TCRT5000 \cite{bib7} nous apprend que la LED émitrice possède une tension directe de 1.25V et n'accepte que jusqu'à 60mA.
			Afin de ne pas surcharger la sortie à 1.8V fournie par le BBG (qui ne fournit pas plus de 50mA), nous alimenterons les LEDs en 5V via une résistance de 120$\Omega$, faisant ainsi traverser la LED par $\frac{5-1.25}{120}=31mA$, ce qui est idéal (intensité IR suffisement élevée sans risquer "d'éblouir" les autres capteurs ou de griller la LED).\\

			On connectera le collecteur du phototransitor à la ligne 1.8V au travers d'une résistance de pull-up de 2.7k$\Omega$, la valeur la plus élevée de résistance nous permettant d'assurer un courant de collecteur de 5mA (comme recommandé dans la datasheet). Nous choisissons la valeur la plus élevée afin de limiter la consommation en courant, mais surtout d'augmenter la sensibilité du capteur (il sera ainsi plus facile au phototransistor de "tirer" la tension vers le bas).\\

			Nous avons donc le schéma de principe suivant :
			\illu{reflecteur.pdf}{Schéma de principe d'un réflecteur optique}{2}

			L'intégration et l'agencement des capteurs sont discutés en \ref{integrationReflecteurs} (page \pageref{integrationReflecteurs}).

		\paragraph{Acquisition d'images}



		\paragraph{Evaluation des distances}

			$\Rightarrow$Distance parcourues\\
			$\Rightarrow$Distance des obstacles\\

		\paragraph{Signalisation de ses intentions}



		\paragraph{Interraction avec l'utilisateur}



		\paragraph{Batterie}



	\subsubsection{Implémentation logicielle}

	\textit{Difficile de rentrer beaucoup dans les détails puisqu'il s'agit de la partie la plus variable des robots (destinés à être programmés par les élèves, les chercheurs). Nous allons cependant expliciter rapidement comment nous réaliserons les codes livrés avec le robot (le but n'étant pas de réaliser les programmes dans ce dossier).}

		\paragraph{Suivi de ligne}

		\paragraph{Reconnaissance d'image}

