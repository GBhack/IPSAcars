\subsection{Circuit}

	\subsubsection{Intégration Matérielle}

		\paragraph{Circuit en lui-même}
			Notre circuit sera donc bien composé de deux parties, chacune constituée d'un panneau de médium monté sur un cadre en tasseaux.
			D'autres problématiques ont fait leur apparition en cours d'étude du projet et c'est ainsi que l'on intègrera des perçages pour la fixation des feux et le passage des fils, mais surtout pour l'intégration des fameux "caches" permettant d'isoler visuellement les "rues".\\

			Les panneaux seront peints en noir et recouverts de scotch d'électricien blanc représentant les lignes. Nous obtenons ainsi un rapport de contraste idéal (noir mat du bois et blanc brillant du ruban adhésif). Le plan à l'échelle de la piste est le suivant :
			\illu{CIRCUIT.pdf}{Plan à l'échelle de la piste}{0.065}

			\vspace{15pt}

			Y apparaissent les lignes, code-barres et caches (en gris plein) évoqués dans le dossier. Les rayons de courbure sont de 75mm, et l'espacement entre les voies et divers obstacles de 220mm.\\

			Un plan contenant toutes les côtes sera produit et pourra être "recopié" à l'aide de simple matériel scolaire (compas, règle, équerre) sur les panneaux avant d'être recouvert par le ruban adhésif.\\

			Les capteurs ILS seront fixés aux panneaux.\\
			On prévoiera des vis "dépassant" aux emplacements appropriés afin de pouvoir y "emboiter" les feux.\\

			Le câblage des capteurs et des feux sera solidaire de chaque partie, et passera par des trous prévus à cet effet dans les tasseaux pour converger en un "faisceau" terminé par un connecteur pour chacune des deux parties. Un connecteur sera présent du côté de chaque feu avec suffisemment de longueur de câble pour pouvoir facilement procéder à l'installation desdits feux.

		\paragraph{Carte électronique}

			\textbf{\Huge{\textcolor{red}{[MAXIME]}}}

	\subsubsection{Intégration Logicielle}

		Le cas du feu de circulation s'adaptant au trafic est l'exemple type de la logique dite de "l'automate fini". La littérature ne manque pas à ce sujet et nous avons même eu l'occasion de l'étudier au cours de notre cursus.\\

		La logique VHDL \nomenclature{VHDL}{VHSIC1 Hardware Description Language : langage destiné à la programmation de cartes FPGA.} est particulièrement adaptée à ce type de problématique et offre la possibilité de coder un certain nombre d'états et de définir les conditions et modalités de changement d'état.\\

		Dans notre cas, nous compterions trois états:
		\begin{itemize}
			\item \textbf{Etat 0} : Tous les feux au rouge.
			\item \textbf{Etat 1} : Couple de feux A au rouge et couple B au vert.
			\item \textbf{Etat 2} : Couple de feux B au rouge et couple A au vert.
		\end{itemize}

		\vspace {12pt}
		Une succession classique d'états serait 0->1->0->2->0->...\\
		Pour simplifier l'organisation du programme, nous pourrions créer un état intermédiaire entre 1 et 2, identique à l'état 0.\\

		Un diviseur d'horloge permettrait de générer des évenements à intervales réguliers afin de cadencer le changements d'états.\\
		Les capteurs eux-mêmes pourraient générer un évènement (sur un front montant de l'entrée logique à laquelle ils sont branchés par exemple) qui, si un certain nombre de conditions sont réunies, anticiperaient le changement d'état (si une voiture se présente à un feu rouge et qu'aucune ne "profite" des feux verts, alors il est plus logique d'inverser cet état),

\subsection{Robot}

	\subsubsection{Intégration Matérielle}

		\paragraph{Ensembles propulsifs}

			\textbf{\Huge{\textcolor{red}{[INTEGRER PARTIE MA]}}}

			Les deux "ensembles de propulsion" seront placés à l'arrière du robot. Une simple bille multidirectionnelle sera placée l'avant pour assurer la stabilité du robot.

			Comme évoqué précédemment, le motoréducteur choisi est associable avec une roue et un encodeur du même constructeur qui forment un ensemble fonctionnel et simple à implémenter. Nous y associerons un support PVC adapté pour la fixation.\\
			Notons qu'un seul des deux moteurs sera équipé d'un encodeur, deux étant superflus et évidemment plus chers.

			Le motoréducteur est équipé de deux fils d'alimentation. Nous les connecterons à la carte-mère au travers d'un bornier. Un double pont en H intégré L293D (comprenant les diodes de roue libre \cite{bib17}) permettra de faire le lien entre le signal PWM généré par le BBG (3.3V limité à une vingtaine de milliampères) et le moteur (que l'on alimentera directement sur la batterie, le signal PWM étant donc adapté sur une base 7.2V). Trois sorties seront donc utilisées sur le BBG pour chacun des deux moteurs : une PWM pour gérer la puissance transmise au moteur, et deux digitales pour le sens de rotation. Ces signaux (de 3.3V) pourront-être directement transmis au double pont en H (le L293D ayant une tension "niveau haut" de 2,3V \cite{bib17}). Nous compterons deux sources d'alimentation pour le pont en H : une alimentation de 5V pour le circuit logique et une alimentation directe sur la batterie (on pensera à intégrer deux condensateurs pour filtrer le bruit dû aux moteurs). Les signaux logiques viendront directement du BBG.\\

			Pour plus de détail, voir \ref{carteMere} (page \pageref{carteMere}).\\

			L'encodeur peut, d'après sa fiche technique \cite{bib9} fonctionner en 3.3V. Cependant, la diode émettrice IR perdra alors de son intensité. Nous procéderons donc à une expérience pour définir si ce fonctionnement en "sous régime" de la diode est satisfaisant. Dans le cas contraire, nous alimenterons l'encodeur en 5V et procéderons à une division de tension sur le signal de sortie avant de le transmettre au BBG, pour ne pas endommager ce dernier. Notons qu'un seul des deux "canaux" de l'encodeur nécessitera d'être connecté au BBG étant donné notre besoin de précision. Ainsi, la carte- mère devra comprendre un connecteur trois contacts dédié à l'encodeur : deux contacts serviront simplement à l'alimentation, et le troisième (le signal) sera connecté à l'une des entrées du BBG permettant l'utilisation du module eQEP (voir \ref{eQEP}).

		\paragraph{Carte Réflecteurs Optiques}\label{integrationReflecteurs}

			Rappelons que nous utiliserons les entrées analogiques du BBG pour effectuer l'acquisition des données du capteur, et que ces dernières sont limitées à 1.8V (voir \ref{solutionSuiviLigne}, page \pageref{solutionSuiviLigne}).

			La datasheet du TCRT5000 \cite{bib7} nous apprend que la LED émettrice possède une tension directe de 1.25V et n'accepte que jusqu'à 60mA.
			Afin de ne pas surcharger la sortie à 1.8V fournie par le BBG (qui ne fournit pas plus de 50mA), nous alimenterons les LEDs en 5V via une résistance de 120$\Omega$, faisant ainsi traverser la LED par $\frac{5-1.25}{120}=31mA$, ce qui est idéal (intensité IR\nomenclature{IR}{Infra-Rouge} suffisamment élevée sans risquer "d'éblouir" les autres capteurs ou de griller la LED).\\

			On connectera le collecteur du phototransistor à la ligne 1.8V au travers d'une résistance de pull-up de 2.7k$\Omega$, la valeur la plus élevée de résistance nous permettant d'assurer un courant de collecteur de 5mA (comme recommandé dans la datasheet). Nous choisissons la valeur la plus élevée afin de limiter la consommation en courant, mais surtout d'augmenter la sensibilité du capteur (il sera ainsi plus facile au phototransistor de "tirer" la tension vers le bas).\\

			Nous avons donc le schéma de principe suivant :
			\illu{reflecteur.pdf}{Schéma de principe d'un réflecteur optique}{2}

			Ce schéma sera reproduit sept fois sur une carte dédiée, qui sera placée à l'avant du robot, parfaitement centrée et placée quelques millimètres au dessus de la piste (la datasheet nous apprend que la distance de fonctionnement idéale entre le capteur et le support est de 2.5 mm, avec un domaine de fonctionnement allant de 0.2 à 12mm).\\
			
			Sachant que la ligne au sol aura une épaisseur de 15mm, nous placerons les trois capteurs centraux de manière à ce que, lorsque le capteur central est placé au milieu de la ligne, il ne manque que 2 à 3mm aux deux autres pour y arriver . Les autres capteurs pourront avoir un écartement légèrement plus élevé :

			\illu{espacementReflecteurs.pdf}{Espacement des réflecteurs optiques}{0.8}

			Notons que la distance exacte entre les capteurs ne pourra être précisément définie que par l'expérience. En effet, nous n'avons aucune indication quant à la largeur du champ de détection du capteur.\\

			Nous connecterons la carte au moyen d'une nappe HE10 à 10 connecteurs.\\

			Le schéma électronique et les gerbers du circuit imprimés sont disponibles en annexe \ref{schemasCarteReflecteurs} (page \pageref{schemasCarteReflecteurs})

		\paragraph{Carte-Mère}\label{carteMere}

			
			\textbf{\Huge{\textcolor{red}{[MAXIME]}}}


		\paragraph{Structure du robot}

			L'intégration de tous les composants du robot passe forcément par un support, une structure d'ensemble.\\
			Nous avons choisi de réaliser cette structure sur une base de profilé aluminium de type "cornière égale" extrêmement simple à se procurer (dans toute enseigne de bricolage), peu chère, mais surtout très simple à usiner avec peu de matériel (l'aluminium étant très tendre, une simple visseuse suffit pour le perçage, une scie et une vis à métaux complétant l'outillage nécessaire).
			Un "cadre" en aluminium constituerai donc le châssis du robot. Ce cadre serait surmonté de quatre montants verticaux destinés à porter LEDs et caméra, et qui pourraient servir à fixer des "caches" pour fermer le robot (à la fois pour l'aspect esthétique et pour l'isolation lumineuse, afin de faciliter le travail de reconnaissance d'image). Un fond en médium ou en plexiglas abriterait le contrôleur et la batterie.\\

			L'idée maîtresse est de standardiser les matériaux et de penser au plus simple. Ainsi, nous essaierons tant que possible de tout faire avec un profilé aluminium unique (cornière égale de 30mm par 30mm), un seul type de vis et d'écrou (M3) et penserons notre assemblage de manière à être aisément réalisable, et ne présentant pas de risque de sur-contrainte.\\

			Le résultat vous est présenté à la section suivante : "Intégration globale, maquette numérique".

		\paragraph{Intégration globale, maquette numérique}

			Une maquette Catia nous a permis de définir le détail de la forme de la structure évoquée à la section précédente, mais également de prévoir l'intégration de tous les éléments.\\

			Tous les éléments de la maquettes ont été reproduits à partir des plans fournis par les constructeurs de composants sélectionnés. Ainsi, la maquette peut servir de plan d'usinage et de montage : aucune dimension n'est issue d'une quelconque approximation.

			\illu{ROBOT1.png}{Rendu de la maquette 3D du robot}{0.4 }
			\vspace{30pt}
			\illu{ROBOT2.png}{Rendu de la maquette 3D du robot}{0.4}

			\illu{ROBOT3.png}{Rendu de la maquette 3D du robot}{0.4}

			Le robot mesure 145mm de large (hors roues, 190 avec les roues), 200mm de long, et 150mm de haut.\\

			La maquette nous a permis d'évaluer le besoin en matériaux à :

			\begin{itemize}
				\item 1540mm de profilé aluminium.
				\item 4 vis M3 de 6mm de long.
				\item 24 vis M3 de 10mm de long (ou autant de vis auto-perçantes selon si l'on souhaite privilégier la facilité de fabrication ou la durée de vie).
				\item 10 vis M3 de 20mm de long.
				\item 34 écrous M3.
				\item 2 entretoises M3 de 15mm.
				\item 3 vis M2 de 10mm de long et autant d'écrous (pour le montage de la bille avant).
				\item une planche de medium de 3mm d'épaisseur en 140 par 200mm.
			\end{itemize}

	\subsubsection{Intégration Logicielle}\label{integrationLogicielle}

		L'intégration logicielle est sans aucun doute la partie la plus complexe de ce projet. Nous disposons d'un certain nombre d'entrées dont l'analyse simultanée permettra, au travers d'algorithmes relativement complexe, devra donner un ensemble de sorties cohérentes. Mais surtout, nous voulons que notre système soit modulaire, et que certaines parties de nos codes puissent être remplacés par d'autres, tout en assurant le fonctionnement des autres.\\

		Tout ceci ne pourra être effectué qu'au travers d'une architecture rigoureuse et largement pensée en amont (hors de question de se lancer dans le code comme on peut souvent le faire dans le cadre d'autres projets). Notons également que la construction d'une documentation et de codes clairement structurés et commentés sera également primordiale.\\

		Nous avons imaginé une structure en modules à quatre étages, au travers desquels l'information irait en descendant :

		\begin{itemize}
			\item \textbf{Les modules "Capteurs"} représenteraient le premier étage.\\
			Ces modules liraient directement la valeur des capteurs au travers des ports d'entrée physiques du contrôleur et produiraient une sortie adaptée.\\
			\textit{Par exemple, le module capteur" associé aux réflecteurs renverrait un vecteur de 7 bits correspondant à la présence ou non d'une ligne blanche sous chacun des capteurs : [1001001] correspondrait ainsi sans doute au passage d'un code barre. Plus compliqué, le module "capteur" associé à la caméra renverrait quatre matrices binaires 100x100 (une pour le vert, une pour le rouge, et une pour le jaune) dans lesquelles la présence d'un "1" indiquerait la détection d'une LED allumée aux cordonnées arrondies correspondantes.}
			\item \textbf{Les modules "Synthétiseur"} ne seraient pas liés à un capteur mais à une problématique. Ils pourront pour y répondre, analyser et synthétiser les données issues de plusieurs multiples modules capteurs.\\
			\textit{Ainsi, le synthétiseur lié à la problématique "lecture de codes barres" se renseignera auprès des modules capteurs "Réflecteurs optiques" et "Encodeur" afin de détecter la présence d'un code-barre et, le cas échéant, sa signification.}
			\item \textbf{Le module "Ordonnanceur"} serait a-priori unique. Il joue le rôle de chef d'orchestre et serait le seul module à intégrer la notion de temporalité (capacité de planification, et "mémoire" des événements récents). Ce serait également le seul module capable de faire "remonter de l'information" pour paramétrer le comportement des synthétiseurs.\\
			\textit{Par exemple, 25cm après la lecture d'un code-barre, l'ordonnanceur demanderait au synthétiseur dédié au suivi de ligne de ne plus se concentrer que sur une partie des réflecteurs optiques.}\\
			L'ordonnanceur fonctionnera forcément selon une logique séquentielle mais devra, pour être robuste et "clair", être décomposé en sous-modules (organe de décision, organe de planification, module dédié au gaz et module dédié à la direction, par exemple).
			\item \textbf{Les modules "Actionneurs"} recevraient des ordres (absolus ou relatifs) de la part de l'ordonnanceur et auraient pour rôle de les mettre en action au travers des sorties physiques du contrôleur.\\
			\textit{Concrètement, deux actionneurs géreront les sorties LEDs et les deux motoréducteurs. Un exemple "d'ordre absolu" pourrait-être "Vitesse = 0" tandis qu'un exemple d'ordre "relatif" serait "+5\% de rayon de virage".}
		\end{itemize}

		\vspace{15pt}

		Voici une simple illustration de la structure ici évoquée :
		\begin{figure}[H]
			\centering
			\input{Graphics/tikz/architectureLogicielle}
			\vspace{10pt}
			\caption{Structure logicielle en "modules"}
		\end{figure}

		Tous ces modules constitueraient l'un des livrables du projet et seraient codés en python, en suivant une approche "objet". A sa réception, le robot devra pouvoir être mis sous tension et évoluer en autonomie. Mais le réel enjeu du projet sera de faire en sorte que ces modules soient parfaitement documentés et architecturés, de manière à ce qu'un utilisateur souhaitant, par exemple, développer son propre module de reconnaissance d'image en C++ puisse faire fonctionner ce dernier avec le reste de nos modules (pour ne pas avoir à se préoccuper d'une partie suivi de ligne qui ne l 'intéresse pas).\\
		Ceci sera rendu possible, notamment, par l'utilisation optionnelle (mais intégrée) de sockets locaux UDP pour communiquer entre les modules.\\

		Un programme principal aurait pour rôle de gérer l’exécution des différents modules, et de répartir intelligemment leur utilisation processeur. Ce programme, lui même codé en python, sera conçu pour fonctionner nativement avec l'ensemble de nos modules, mais sera également capable d’exécuter des modules tiers. Ce programme devra lui-même faire preuve d'une très grande rigueur. Son fonctionnement sera régi par la lecture d'un fichier de configuration à son initialisation. Ainsi, ce fichier de configuration pourra déterminer quels modules devront-être exécutés, et avec quel paramétrage.\\

		Un scenario possible serait :\\
		\textit{Exécuter tous les modules natifs sauf le module synthétiseur spécialisé en reconnaissance de feux qui sera remplacé par le programme "monProgramme.exe" placé à la racine. Le module capteur "sonar" devra communiquer sur le port 40052. Les autres modules seront chargés en configuration par défaut.}\\
		Ces instructions seraient définies dans le fichier de configuration, et leur exécution serait assurée par le programme principal. Évidemment, ceci ne pourra fonctionner que si l'utilisateur a très soigneusement suivi les recommandations de la documentation lui indiquant quel type de données doit fournir le module synthétiseur spécialisé en reconnaissance de feux.\\

		Encore une fois, rien n'obligera l'utilisateur à se servir de cette base logicielle. Il pourra très bien décider d'ignorer totalement le système en place et concevoir le sien. Le but de ce système est vraiment de permettre à un élève de se concentrer sur une problématique ciblée en voyant les autres traitées pour lui. Mais cela ne peut se faire que si son propre module n'empêche pas le fonctionnement des autres. Ceci ne peut être le cas que si son module est parfaitement additionnel (et fait donc un travail dont le résultat n'est requis par aucun autre module) ou si il est parfaitement compatible avec les autres (et transmet donc les données dans le même format et selon le même protocole que le module natif).\\

		Nous ne pouvons pas insister suffisemment sur le fait que ceci ne représente que l'approche théorique du problème. Si nous l'avons longuement pensé et réfléchi, ce travail n'est absolument pas suffisent pour donner lieu à une phase de développement : celle-ci devra être précédée d'une phase de préparation minutieuse, notemment en utilisant les outils de "Model Driven Engineering" (diagrames de classes, d'interaction...) afin de mettre en place un cadre de travail strict et rigoureux absolument nécéssaire à la réussite d'un projet de ce type.